<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>电商数仓-测试与优化</title>
      <link href="/2021/11/17/shu-ju-cang-ku-fen-ceng/"/>
      <url>/2021/11/17/shu-ju-cang-ku-fen-ceng/</url>
      
        <content type="html"><![CDATA[<h2 id="数据库分层图"><a href="#数据库分层图" class="headerlink" title="数据库分层图"></a>数据库分层图</h2><p><img src="/2021/11/17/shu-ju-cang-ku-fen-ceng/387d3d14-02d2-4a6d-940c-29fa6232be81.png"></p><h2 id="数据库各层的功能解析"><a href="#数据库各层的功能解析" class="headerlink" title="数据库各层的功能解析"></a>数据库各层的功能解析</h2><ol><li><p>ODS：元数据层，对于原始数据的一个备份</p></li><li><p>DWD：数据明细层，对数据的一个清洗（判空过滤，去除脏数据），保存业务事实明细，一行数据代表用户的一次业务行为。如：一次下单。</p></li><li><p>ADS：数据应用层，为各种报表提供数据支持。</p></li><li><p>DIM：维度层，对数据的维度建模主要是业务事实信息的描述。何人，何时，何地</p></li><li><p>DWS：服务数据层，按天进行轻度汇总。一行信息代表一个主题对象的一天汇总行为。</p></li><li><p>DWT：主题数据层，数据累计汇总，一行信息代表一个主题对象的一段时间数据的累计汇总。</p></li></ol><h2 id="为什么要数据分层："><a href="#为什么要数据分层：" class="headerlink" title="为什么要数据分层："></a>为什么要数据分层：</h2><ol><li><p>隔离原始数据：对数据进行备份，解耦（将原始数据和统计数据据解耦开）。</p></li><li><p>减少重复开发：规范数据分层，通过中间层数据，减少数据的重复开发，一次计算多次复用。</p></li><li><p>把复杂任务简单化： 把任务分层处理，每层只处理简单问题。方便问题的定位。<br>命名规范</p></li></ol><hr><ul><li>   表名</li></ul><p>Ø  ODS层命名为ods_表名</p><p>Ø  DIM层命名为dim_表名</p><p>Ø  DWD层命名为dwd_表名</p><p>Ø  DWS层命名为dws_表名  </p><p>Ø  DWT层命名为dwt_表名</p><p>Ø  ADS层命名为ads_表名</p><p>Ø  临时表命名为tmp_表名</p><ul><li>脚本名<br>数据源_to_目标_db/log.sh<br>行为数据：log<br>业务数据：db</li><li>   字段类型<br>金钱：decimal(16,2), edit:16表示16位有效数字，2表示，其中小数部分为2位<br>数量：bigint<br>时间戳类型：bigint</li></ul><p>主外键类型为：string<br>建模理论</p><hr><h3 id="关系建模"><a href="#关系建模" class="headerlink" title="关系建模"></a>关系建模</h3><p>遵循三范式</p><ol><li><p>属性不可切</p></li><li><p>部分函数依赖不可有<br> 非主键不可部分函数依赖于主键</p></li><li><p>传递函数依赖不可有<br> 非主键不可传递函数依赖于主键</p></li></ol><p>###维度建模</p><h4 id="维度表"><a href="#维度表" class="headerlink" title="维度表"></a>维度表</h4><p>对事实的描述。包含大量属性。</p><h4 id="事实表"><a href="#事实表" class="headerlink" title="事实表"></a>事实表</h4><p>业务事件</p><p>维度表的外键+度量值</p><ul><li>事实表的类型分类：</li></ul><ol><li>事务型事实表<br>使用增量同步</li><li>周期型快照事实表<br>使用全量同步</li><li>累积周期性快照事实表<br>使用增量修改同步</li></ol><p><strong>业务总线矩阵</strong></p><table><thead><tr><th align="left">事实\维度</th><th align="center">时间</th><th align="center">用户</th><th align="center">地区</th><th align="center">商品</th><th align="center">优惠券</th><th align="center">活动</th><th align="center">度量值</th></tr></thead><tbody><tr><td align="left">订单</td><td align="center">&radic;</td><td align="center">&radic;</td><td align="center">&radic;</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center">运费,优惠金额</td></tr><tr><td align="left">订单明细</td><td align="center">&radic;</td><td align="center">&radic;</td><td align="center">&radic;</td><td align="center">&radic;</td><td align="center">&radic;</td><td align="center">&radic;</td><td align="center">商品件数,订单金额,优惠金额</td></tr><tr><td align="left">支付</td><td align="center">&radic;</td><td align="center">&radic;</td><td align="center">&radic;</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center">支付金额</td></tr><tr><td align="left">加购</td><td align="center">&radic;</td><td align="center">&radic;</td><td align="center"></td><td align="center">&radic;</td><td align="center"></td><td align="center"></td><td align="center">商品件数,金额</td></tr><tr><td align="left">收藏</td><td align="center">&radic;</td><td align="center">&radic;</td><td align="center"></td><td align="center">&radic;</td><td align="center"></td><td align="center"></td><td align="center">收藏次数(1)</td></tr><tr><td align="left">退单</td><td align="center">&radic;</td><td align="center">&radic;</td><td align="center"></td><td align="center">&radic;</td><td align="center"></td><td align="center"></td><td align="center">商品件数,退单金额</td></tr><tr><td align="left">退款</td><td align="center">&radic;</td><td align="center">&radic;</td><td align="center"></td><td align="center">&radic;</td><td align="center"></td><td align="center"></td><td align="center">商品件数,退款金额</td></tr><tr><td align="left">评价</td><td align="center">&radic;</td><td align="center">&radic;</td><td align="center"></td><td align="center">&radic;</td><td align="center"></td><td align="center"></td><td align="center">评价次数(1)</td></tr><tr><td align="left">优惠券领用</td><td align="center">&radic;</td><td align="center">&radic;</td><td align="center"></td><td align="center"></td><td align="center">&radic;</td><td align="center"></td><td align="center">领券次数(1)</td></tr></tbody></table><ul><li><input checked disabled type="checkbox"> 理解没有</li></ul>]]></content>
      
      
      <categories>
          
          <category> Data Warehouse </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Data Warehouse </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git常规指令</title>
      <link href="/2021/11/17/git-chang-gui-zhi-ling/"/>
      <url>/2021/11/17/git-chang-gui-zhi-ling/</url>
      
        <content type="html"><![CDATA[<h1 id="一些常用指令汇总"><a href="#一些常用指令汇总" class="headerlink" title="一些常用指令汇总"></a>一些常用指令汇总</h1><ul><li> edit:<br>  昨天提交考试作业,需要提交到gitee上的分支上.因为很久没用git了,有点忘记了.今早在此做一次昨天命令汇总复习吧.</li></ul><h2 id="首先建立本地仓库-初始化"><a href="#首先建立本地仓库-初始化" class="headerlink" title="首先建立本地仓库,初始化"></a>首先建立本地仓库,初始化</h2><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token function">git</span> init<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="remote-一下远程仓库"><a href="#remote-一下远程仓库" class="headerlink" title="remote 一下远程仓库"></a>remote 一下远程仓库</h2><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token function">git</span> remote <span class="token function">add</span> origin https://gitee.com/xxxx<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="pull一下我的分支-学号"><a href="#pull一下我的分支-学号" class="headerlink" title="pull一下我的分支(学号)"></a>pull一下我的分支(学号)</h2><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token function">git</span> pull origin 学号<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="添加本地仓库"><a href="#添加本地仓库" class="headerlink" title="添加本地仓库"></a>添加本地仓库</h2><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token function">git</span> <span class="token function">add</span> <span class="token builtin class-name">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="commite-一下"><a href="#commite-一下" class="headerlink" title="commite 一下"></a>commite 一下</h2><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token function">git</span> commit -m <span class="token string">"初始"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="切换分支到我的学号"><a href="#切换分支到我的学号" class="headerlink" title="切换分支到我的学号"></a>切换分支到我的学号</h2><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token function">git</span> checkout 学号<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="push到仓库分支"><a href="#push到仓库分支" class="headerlink" title="push到仓库分支"></a>push到仓库分支</h2><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token function">git</span> push origin 学号<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="删除本地仓库"><a href="#删除本地仓库" class="headerlink" title="删除本地仓库"></a>删除本地仓库</h2><p>**edit:**直接把本地的”.git”文件删除就行了,采用shell命令</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token function">find</span> <span class="token builtin class-name">.</span> -name <span class="token string">".git"</span><span class="token operator">|</span><span class="token function">xargs</span> <span class="token function">rm</span> -rf<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UDTF原理</title>
      <link href="/2021/11/16/udtf/"/>
      <url>/2021/11/16/udtf/</url>
      
        <content type="html"><![CDATA[<h2 id="原理解释"><a href="#原理解释" class="headerlink" title="原理解释"></a>原理解释</h2><p>Hive 的每一个sql会被解释成一个个的operator组成operators,<br>数据放在java中的object中,<br>数据类型放在object inspector中<br>在oprator之间传递.</p><blockquote><p>edit:<br>(object inspector提供了用以解析保存在object中的数据的方法)</p></blockquote><p><img src="https://img-blog.csdnimg.cn/b45be8e0b8894b7c97973d2b0769f95c.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5oiR5piv5aW95Lq65aSn5oCq5YW9,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="这是从我的csdn引用的"><br><img src="/2021/11/16/udtf/udtf.png" alt="这是安装插件后,从相对路径引用的"><br><a href="https://f60bec40.wiz06.com/wapp/pages/view/share/s/3S2-N02Et17F2tGvlH3MdUWD0HjvNV08rABS2UL3b20OfkF7">我的为知笔记</a></p>]]></content>
      
      
      <categories>
          
          <category> hive </category>
          
      </categories>
      
      
        <tags>
            
            <tag> udtf </tag>
            
            <tag> hive </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>电商数仓-测试与优化</title>
      <link href="/2021/11/16/ebdw-testandoptimize/"/>
      <url>/2021/11/16/ebdw-testandoptimize/</url>
      
        <content type="html"><![CDATA[<h1 id="电商数据仓库项目"><a href="#电商数据仓库项目" class="headerlink" title="电商数据仓库项目"></a>电商数据仓库项目</h1><h2 id="基准测试"><a href="#基准测试" class="headerlink" title="基准测试"></a>基准测试</h2><h3 id="为什么要做基准测试"><a href="#为什么要做基准测试" class="headerlink" title="为什么要做基准测试?"></a>为什么要做基准测试?</h3><p>在企业中非常关心每天从Java后台拉取过来的数据，需要多久能上传到集群？消费者关心多久能从HDFS上拉取需要的数据？</p><p>为了搞清楚HDFS的读写性能，生产环境上非常需要对集群进行压测。</p><h3 id="怎么做"><a href="#怎么做" class="headerlink" title="怎么做"></a>怎么做</h3><ul><li> <strong>第一步</strong>,<em><strong>设置统一网络传输速度</strong></em>    *    hadoop102、hadoop103、hadoop104虚拟机网络都设置为100mbps。<br>  原因:HDFS的读写性能主要受网络和磁盘影响比较大。<br>edit:    100Mbps单位是bit；10M/s单位是byte ; 1byte=8bit，100Mbps/8=12.5M/s。<br><img src="/2021/11/16/ebdw-testandoptimize/b5795d33-9457-458f-95ac-85505eb55a88.png">    * 开启python的简单http服务器进行网速测试  <pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">    [tzk@hadoop101 module]$ python -m SimpleHTTPServerServing HTTP on 0.0.0.0 port 8000 ...192.168.32.1 - - [07&#x2F;Oct&#x2F;2021 19:42:38] &quot;GET &#x2F; HTTP&#x2F;1.1&quot; 200 -192.168.32.1 - - [07&#x2F;Oct&#x2F;2021 19:42:38] code 404, message File not found192.168.32.1 - - [07&#x2F;Oct&#x2F;2021 19:42:38] &quot;GET &#x2F;favicon.ico HTTP&#x2F;1.1&quot; 404 -192.168.32.1 - - [07&#x2F;Oct&#x2F;2021 19:42:43] &quot;GET &#x2F;bigtable.lzo HTTP&#x2F;1.1&quot; 200 -<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>    * 验证结果  <img src="/2021/11/16/ebdw-testandoptimize/fd789e7f-76c7-40e4-889a-96d36d6f8bc6.png"></li><li><strong>第二步</strong>,<em><strong>测试hdfs的写性能</strong></em><br>向HDFS写10个128M的文件<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[tzk@hadoop101 hadoop-3.1.3]$ hadoop jar share&#x2F;hadoop&#x2F;mapreduce&#x2F;hadoop-mapreduce-client-jobclient-3.1.3-tests.jar TestDFSIO -write -nrFiles 10 -fileSize 128MB <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><img src="/2021/11/16/ebdw-testandoptimize/a0baf880-9449-4ebf-a71f-42a940f3c368.png"><br>两个平均数:<ul><li>第一个的计算方式: 所有数据量相加 <strong>/</strong> 总时间</li><li>第二个的计算方式: 每一个map的平均速度相加</li></ul></li></ul><p>由上图可以看出,这两个平均速度远远大于网络速度.很明显,这里走的是磁盘,并没有走网络.<br>即:只在hadoop101上运行,因为我们在一开始把备份数改成了1.现在去hdfs-site.xml进行修改为3<br><strong>来看一下运行结果图</strong><br><img src="/2021/11/16/ebdw-testandoptimize/4fd8e791-e9dd-4082-a425-caddb58e8a29.png"><br>10个任务,由于我们的客户端是在hadoop101上,所以网络传输为 10*20分.<br>那么传输速度为:<br>v X 20<br>实测数据: 1.77 * 20 = 35.4<br>每台服务器速度(按最大值:100 / 8 = 12.5)相加: 12.5 + 12.5 + 12.5 = 37.5<br>由此可得,带宽已经跑满了</p><ul><li><strong>第三步</strong>,<em><strong>测试HDFS的读性能</strong></em><br>客户端: hadoop101<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[tzk@hadoop101 hadoop-3.1.3]$ hadoop jar share&#x2F;hadoop&#x2F;mapreduce&#x2F;hadoop-mapreduce-client-jobclient-3.1.3-tests.jar TestDFSIO -read -nrFiles 10 -fileSize 128MB<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><em>测试结果图:</em>*<br><img src="/2021/11/16/ebdw-testandoptimize/57facd70-6104-4316-8214-83f523968f9c.png"></li></ul><p><strong>最后</strong>,<em><strong>删除测试生成数据</strong></em></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[tzk@hadoop101 hadoop-3.1.3]$ hadoop jar share&#x2F;hadoop&#x2F;mapreduce&#x2F;hadoop-mapreduce-client-jobclient-3.1.3-tests.jar TestDFSIO -clean<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="使用Sort程序评测MapReduce"><a href="#使用Sort程序评测MapReduce" class="headerlink" title="使用Sort程序评测MapReduce"></a><em><strong>使用Sort程序评测MapReduce</strong></em></h3><p>（1）使用RandomWriter来产生随机数，每个节点运行10个Map任务，每个Map产生大约1G大小的二进制随机数</p><pre class="line-numbers language-none"><code class="language-none">[atguigu@hadoop102 mapreduce]$ hadoop jar &#x2F;opt&#x2F;module&#x2F;hadoop-3.1.3&#x2F;share&#x2F;hadoop&#x2F;mapreduce&#x2F;hadoop-mapreduce-examples-3.1.3.jar randomwriter random-data<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>（2）执行Sort程序</p><pre class="line-numbers language-none"><code class="language-none">[atguigu@hadoop102 mapreduce]$ hadoop jar &#x2F;opt&#x2F;module&#x2F;hadoop-3.1.3&#x2F;share&#x2F;hadoop&#x2F;mapreduce&#x2F;hadoop-mapreduce-examples-3.1.3.jar sort random-data sorted-data<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>（3）验证数据是否真正排好序了</p><pre class="line-numbers language-none"><code class="language-none">[atguigu@hadoop102 mapreduce]$hadoop jar &#x2F;opt&#x2F;module&#x2F;hadoop-3.1.3&#x2F;share&#x2F;hadoop&#x2F;mapreduce&#x2F;hadoop-mapreduce-client-jobclient-3.1.3-tests.jar testmapredsort -sortInput random-data -sortOutput sorted-data<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="hadoop参数调优"><a href="#hadoop参数调优" class="headerlink" title="hadoop参数调优"></a>hadoop参数调优</h2><h3 id="1-）HDFS参数调优"><a href="#1-）HDFS参数调优" class="headerlink" title="1 ）HDFS参数调优"></a><strong>1</strong> ）HDFS参数调优</h3><p><strong>hdfs-site.xml</strong></p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">NameNode有一个工作线程池，用来处理不同DataNode的并发心跳以及客户端并发的元数据操作。对于大集群或者有大量客户端的集群来说，通常需要增大参数dfs.namenode.handler.count的默认值10。<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>name</span><span class="token punctuation">></span></span>dfs.namenode.handler.count<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>name</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>value</span><span class="token punctuation">></span></span>10<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>value</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>计算公式</strong><br><img src="/2021/11/16/ebdw-testandoptimize/bb5a529f-803b-4b8b-ad8c-27ca2108be24.png"></p><p>通过python实现计算</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[tzk@hadoop101 hadoop-3.1.3]$ pythonPython 2.7.5 (default, Apr  2 2020, 13:16:51) [GCC 4.8.5 20150623 (Red Hat 4.8.5-39)] on linux2Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.&gt;&gt;&gt; import math&gt;&gt;&gt; print int(20*math.log(3))21&gt;&gt;&gt; quit()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-）YARN参数调优"><a href="#2-）YARN参数调优" class="headerlink" title="2 ）YARN参数调优"></a><strong>2</strong> ）YARN参数调优</h3><p><strong>yarn-site.xml</strong><br>（1）情景描述：总共7台机器，每天几亿条数据，数据源-&gt;Flume-&gt;Kafka-&gt;HDFS-&gt;Hive</p><p>面临问题：数据统计主要用HiveSQL，没有数据倾斜，小文件已经做了合并处理，开启的JVM重用，而且IO没有阻塞，内存用了不到50%。但是还是跑的非常慢，而且数据量洪峰过来时，整个集群都会宕掉。基于这种情况有没有优化方案。</p><p>（2）解决办法：</p><p>NodeManager内存和服务器实际内存配置尽量接近，如服务器有128g内存，但是NodeManager默认内存8G，不修改该参数最多只能用8G内存。NodeManager使用的CPU核数和服务器CPU核数尽量接近。</p><p>①yarn.nodemanager.resource.memory-mb   NodeManager使用内存数</p><p>②yarn.nodemanager.resource.cpu-vcores  NodeManager使用CPU核数</p><h2 id="kafka压测"><a href="#kafka压测" class="headerlink" title="kafka压测"></a>kafka压测</h2><h3 id="生产压测"><a href="#生产压测" class="headerlink" title="生产压测"></a>生产压测</h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">kafka-topics.sh --zookeeper hadoop101:2181,hadoop102:2181,hadoop103:2181&#x2F;kafka --create --replication-factor 2 --partitions 3 --topic test#再来一遍kafka-topics.sh --zookeeper hadoop101:2181,hadoop102:2181,hadoop103:2181&#x2F;kafka --create --replication-factor 2 partitions 3 --topic test#在来亿遍kafka-topics.sh --zookeeper hadoop101:2181,hadoop102:2181,hadoop103:2181&#x2F;kafka --create --replication-factor 2 --partitions 3 --topic test#生产测试kafka-producer-perf-test.sh  --topic test --record-size 100 --num-records 10000000 --throughput -1 --producer-props bootstrap.servers&#x3D;hadoop101:9092,hadoop102:9092,hadoop103:9092kafka-producer-perf-test.sh --topic test --record-size 100 --num-records 10000000 --throughput -1 --producer-props bootstrap.servers&#x3D;hadoop101:9092,hadoop102:9092,hadoop103:9092<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>测试结果图:<br><img src="/2021/11/16/ebdw-testandoptimize/25ec958a-9caf-446e-b8f1-3108cc678cb9.png"><br>集群总带宽: 12.5 + 12.5 + 12.5 约等于 10 + 10 + 10 = 30M/s<br>由于有两个副本,则传输速度应该为: 30 / 2 = 15M/s<br><font color="red"><em>测试结果与预期相符</em></font></p><h3 id="消费压测"><a href="#消费压测" class="headerlink" title="消费压测"></a>消费压测</h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">kafka-consumer-perf-test.sh --broker-list hadoop101:9092,hadoop102:9092,hadoop103:9092 --topic test --fetch-size 10000 --messages 10000000 --threads 1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/2021/11/16/ebdw-testandoptimize/0f7172e2-a88d-470a-ac6c-836b934c59af.png"><br>将 fetch-size的值加大10倍</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"># threads 地址对结果没影响,因为底层源码中并没有调取它kafka-consumer-perf-test.sh --broker-list hadoop101:9092,hadoop102:9092,hadoop103:9092 --topic test --fetch-size 100000 --messages 10000000 --threads 1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="/2021/11/16/ebdw-testandoptimize/d59fa9ae-e296-4409-8b77-dd151b80559b.png"></p>]]></content>
      
      
      <categories>
          
          <category> Data Warehouse </category>
          
          <category> bigdata </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Data Warehouse </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql基础</title>
      <link href="/2021/11/16/mysql-ji-chu/"/>
      <url>/2021/11/16/mysql-ji-chu/</url>
      
        <content type="html"><![CDATA[<h2 id="数据库的好处"><a href="#数据库的好处" class="headerlink" title="数据库的好处"></a>数据库的好处</h2><pre><code>1.持久化数据到本地2.可以实现结构化查询，方便管理</code></pre><h2 id="数据库相关概念"><a href="#数据库相关概念" class="headerlink" title="数据库相关概念"></a>数据库相关概念</h2><pre><code>1、DB：数据库，保存一组有组织的数据的容器2、DBMS：数据库管理系统，又称为数据库软件（产品），用于管理DB中的数据3、SQL:结构化查询语言，用于和DBMS通信的语言</code></pre><h2 id="数据库存储数据的特点"><a href="#数据库存储数据的特点" class="headerlink" title="数据库存储数据的特点"></a>数据库存储数据的特点</h2><pre><code>1、将数据放到表中，表再放到库中2、一个数据库中可以有多个表，每个表都有一个的名字，用来标识自己。表名具有唯一性。3、表具有一些特性，这些特性定义了数据在表中如何存储，类似java中 “类”的设计。4、表由列组成，我们也称为字段。所有表都是由一个或多个列组成的，每一列类似java 中的”属性”5、表中的数据是按行存储的，每一行类似于java中的“对象”。</code></pre><h2 id="MySQL产品的介绍和安装"><a href="#MySQL产品的介绍和安装" class="headerlink" title="MySQL产品的介绍和安装"></a>MySQL产品的介绍和安装</h2><h3 id="MySQL服务的启动和停止"><a href="#MySQL服务的启动和停止" class="headerlink" title="MySQL服务的启动和停止"></a>MySQL服务的启动和停止</h3><pre><code>方式一：计算机——右击管理——服务方式二：通过管理员身份运行net start 服务名（启动服务）net stop 服务名（停止服务）</code></pre><h3 id="MySQL服务的登录和退出"><a href="#MySQL服务的登录和退出" class="headerlink" title="MySQL服务的登录和退出"></a>MySQL服务的登录和退出</h3><pre><code>方式一：通过mysql自带的客户端只限于root用户方式二：通过windows自带的客户端登录：mysql 【-h主机名 -P端口号 】-u用户名 -p密码退出：exit或ctrl+C</code></pre><h3 id="MySQL的常见命令"><a href="#MySQL的常见命令" class="headerlink" title="MySQL的常见命令"></a>MySQL的常见命令</h3><pre><code>1.查看当前所有的数据库show databases;2.打开指定的库use 库名3.查看当前库的所有表show tables;4.查看其它库的所有表show tables from 库名;5.创建表create table 表名(    列名 列类型,    列名 列类型，    。。。);6.查看表结构desc 表名;7.查看服务器的版本方式一：登录到mysql服务端select version();方式二：没有登录到mysql服务端mysql --version或mysql --V</code></pre><h3 id="MySQL的语法规范"><a href="#MySQL的语法规范" class="headerlink" title="MySQL的语法规范"></a>MySQL的语法规范</h3><pre><code>1.不区分大小写,但建议关键字大写，表名、列名小写2.每条命令最好用分号结尾3.每条命令根据需要，可以进行缩进 或换行4.注释    单行注释：#注释文字    单行注释：-- 注释文字    多行注释：/* 注释文字  */</code></pre><h3 id="SQL的语言分类"><a href="#SQL的语言分类" class="headerlink" title="SQL的语言分类"></a>SQL的语言分类</h3><pre><code>DQL（Data Query Language）：数据查询语言    select DML(Data Manipulate Language):数据操作语言    insert 、update、deleteDDL（Data Define Languge）：数据定义语言    create、drop、alterTCL（Transaction Control Language）：事务控制语言    commit、rollback</code></pre><h3 id="SQL的常见命令"><a href="#SQL的常见命令" class="headerlink" title="SQL的常见命令"></a>SQL的常见命令</h3><pre><code>show databases； 查看所有的数据库use 库名； 打开指定 的库show tables ; 显示库中的所有表show tables from 库名;显示指定库中的所有表create table 表名(    字段名 字段类型,        字段名 字段类型); 创建表desc 表名; 查看指定表的结构select * from 表名;显示表中的所有数据</code></pre><h2 id="DQL语言的学习"><a href="#DQL语言的学习" class="headerlink" title="DQL语言的学习"></a>DQL语言的学习</h2><h3 id="进阶1：基础查询"><a href="#进阶1：基础查询" class="headerlink" title="进阶1：基础查询"></a>进阶1：基础查询</h3><pre><code>语法：SELECT 要查询的东西【FROM 表名】;类似于Java中 :System.out.println(要打印的东西);特点：①通过select查询完的结果 ，是一个虚拟的表格，不是真实存在② 要查询的东西 可以是常量值、可以是表达式、可以是字段、可以是函数</code></pre><h3 id="进阶2：条件查询"><a href="#进阶2：条件查询" class="headerlink" title="进阶2：条件查询"></a>进阶2：条件查询</h3><pre><code>条件查询：根据条件过滤原始表的数据，查询到想要的数据语法：select     要查询的字段|表达式|常量值|函数from     表where     条件 ;分类：一、条件表达式    示例：salary&gt;10000    条件运算符：    &gt; &lt; &gt;= &lt;= = != &lt;&gt;二、逻辑表达式示例：salary&gt;10000 &amp;&amp; salary&lt;20000逻辑运算符：    and（&amp;&amp;）:两个条件如果同时成立，结果为true，否则为false    or(||)：两个条件只要有一个成立，结果为true，否则为false    not(!)：如果条件成立，则not后为false，否则为true三、模糊查询示例：last_name like &#39;a%&#39;</code></pre><h3 id="进阶3：排序查询"><a href="#进阶3：排序查询" class="headerlink" title="进阶3：排序查询"></a>进阶3：排序查询</h3><pre><code>语法：select    要查询的东西from    表where     条件order by 排序的字段|表达式|函数|别名 【asc|desc】</code></pre><h3 id="进阶4：常见函数"><a href="#进阶4：常见函数" class="headerlink" title="进阶4：常见函数"></a>进阶4：常见函数</h3><pre><code>一、单行函数1、字符函数    concat拼接    substr截取子串    upper转换成大写    lower转换成小写    trim去前后指定的空格和字符    ltrim去左边空格    rtrim去右边空格    replace替换    lpad左填充    rpad右填充    instr返回子串第一次出现的索引    length 获取字节个数    2、数学函数    round 四舍五入    rand 随机数    floor向下取整    ceil向上取整    mod取余    truncate截断3、日期函数    now当前系统日期+时间    curdate当前系统日期    curtime当前系统时间    str_to_date 将字符转换成日期    date_format将日期转换成字符4、流程控制函数    if 处理双分支    case语句 处理多分支        情况1：处理等值判断        情况2：处理条件判断    5、其他函数    version版本    database当前库    user当前连接用户</code></pre><p>二、分组函数</p><pre><code>    sum 求和    max 最大值    min 最小值    avg 平均值    count 计数    特点：    1、以上五个分组函数都忽略null值，除了count(*)    2、sum和avg一般用于处理数值型        max、min、count可以处理任何数据类型    3、都可以搭配distinct使用，用于统计去重后的结果    4、count的参数可以支持：        字段、*、常量值，一般放1       建议使用 count(*)</code></pre><h2 id="进阶5：分组查询"><a href="#进阶5：分组查询" class="headerlink" title="进阶5：分组查询"></a>进阶5：分组查询</h2><pre><code>语法：select 查询的字段，分组函数from 表group by 分组的字段特点：1、可以按单个字段分组2、和分组函数一同查询的字段最好是分组后的字段3、分组筛选        针对的表    位置            关键字分组前筛选：    原始表        group by的前面        where分组后筛选：    分组后的结果集    group by的后面        having4、可以按多个字段分组，字段之间用逗号隔开5、可以支持排序6、having后可以支持别名</code></pre><h2 id="进阶6：多表连接查询"><a href="#进阶6：多表连接查询" class="headerlink" title="进阶6：多表连接查询"></a>进阶6：多表连接查询</h2><pre><code>笛卡尔乘积：如果连接条件省略或无效则会出现解决办法：添加上连接条件</code></pre><p>一、传统模式下的连接 ：等值连接——非等值连接</p><pre><code>1.等值连接的结果 = 多个表的交集2.n表连接，至少需要n-1个连接条件3.多个表不分主次，没有顺序要求4.一般为表起别名，提高阅读性和性能</code></pre><p>二、sql99语法：通过join关键字实现连接</p><pre><code>含义：1999年推出的sql语法支持：等值连接、非等值连接 （内连接）外连接交叉连接语法：select 字段，...from 表1【inner|left outer|right outer|cross】join 表2 on  连接条件【inner|left outer|right outer|cross】join 表3 on  连接条件【where 筛选条件】【group by 分组字段】【having 分组后的筛选条件】【order by 排序的字段或表达式】好处：语句上，连接条件和筛选条件实现了分离，简洁明了！</code></pre><p>三、自连接</p><p>案例：查询员工名和直接上级的名称</p><p>sql99</p><pre><code>SELECT e.last_name,m.last_nameFROM employees eJOIN employees m ON e.`manager_id`=m.`employee_id`;</code></pre><p>sql92</p><pre><code>SELECT e.last_name,m.last_nameFROM employees e,employees m WHERE e.`manager_id`=m.`employee_id`;</code></pre><h2 id="进阶7：子查询"><a href="#进阶7：子查询" class="headerlink" title="进阶7：子查询"></a>进阶7：子查询</h2><p>含义：</p><pre><code>一条查询语句中又嵌套了另一条完整的select语句，其中被嵌套的select语句，称为子查询或内查询在外面的查询语句，称为主查询或外查询</code></pre><p>特点：</p><pre><code>1、子查询都放在小括号内2、子查询可以放在from后面、select后面、where后面、having后面，但一般放在条件的右侧3、子查询优先于主查询执行，主查询使用了子查询的执行结果4、子查询根据查询结果的行数不同分为以下两类：① 单行子查询    结果集只有一行    一般搭配单行操作符使用：&gt; &lt; = &lt;&gt; &gt;= &lt;=     非法使用子查询的情况：    a、子查询的结果为一组值    b、子查询的结果为空    ② 多行子查询    结果集有多行    一般搭配多行操作符使用：any、all、in、not in    in： 属于子查询结果中的任意一个就行    any和all往往可以用其他查询代替</code></pre><h2 id="进阶8：分页查询"><a href="#进阶8：分页查询" class="headerlink" title="进阶8：分页查询"></a>进阶8：分页查询</h2><p>应用场景：</p><pre><code>实际的web项目中需要根据用户的需求提交对应的分页查询的sql语句</code></pre><p>语法：</p><pre><code>select 字段|表达式,...from 表【where 条件】【group by 分组字段】【having 条件】【order by 排序的字段】limit 【起始的条目索引，】条目数;</code></pre><p>特点：</p><pre><code>1.起始条目索引从0开始2.limit子句放在查询语句的最后3.公式：select * from  表 limit （page-1）*sizePerPage,sizePerPage假如:每页显示条目数sizePerPage要显示的页数 page</code></pre><h2 id="进阶9：联合查询"><a href="#进阶9：联合查询" class="headerlink" title="进阶9：联合查询"></a>进阶9：联合查询</h2><p>引入：<br>    union 联合、合并</p><p>语法：</p><pre><code>select 字段|常量|表达式|函数 【from 表】 【where 条件】 union 【all】select 字段|常量|表达式|函数 【from 表】 【where 条件】 union 【all】select 字段|常量|表达式|函数 【from 表】 【where 条件】 union  【all】.....select 字段|常量|表达式|函数 【from 表】 【where 条件】</code></pre><p>特点：</p><pre><code>1、多条查询语句的查询的列数必须是一致的2、多条查询语句的查询的列的类型几乎相同3、union代表去重，union all代表不去重</code></pre><h2 id="DML语言"><a href="#DML语言" class="headerlink" title="DML语言"></a>DML语言</h2><h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><p>语法：<br>    insert into 表名(字段名，…)<br>    values(值1，…);</p><p>特点：</p><pre><code>1、字段类型和值类型一致或兼容，而且一一对应2、可以为空的字段，可以不用插入值，或用null填充3、不可以为空的字段，必须插入值4、字段个数和值的个数必须一致5、字段可以省略，但默认所有字段，并且顺序和表中的存储顺序一致</code></pre><h3 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h3><p>修改单表语法：</p><pre><code>update 表名 set 字段=新值,字段=新值【where 条件】</code></pre><p>修改多表语法：</p><pre><code>update 表1 别名1,表2 别名2set 字段=新值，字段=新值where 连接条件and 筛选条件</code></pre><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>方式1：delete语句 </p><p>单表的删除： ★<br>    delete from 表名 【where 筛选条件】</p><p>多表的删除：<br>    delete 别名1，别名2<br>    from 表1 别名1，表2 别名2<br>    where 连接条件<br>    and 筛选条件;</p><p>方式2：truncate语句</p><pre><code>truncate table 表名</code></pre><p>两种方式的区别【面试题】</p><pre><code>#1.truncate不能加where条件，而delete可以加where条件#2.truncate的效率高一丢丢#3.truncate 删除带自增长的列的表后，如果再插入数据，数据从1开始#delete 删除带自增长列的表后，如果再插入数据，数据从上一次的断点处开始#4.truncate删除不能回滚，delete删除可以回滚</code></pre><h2 id="DDL语句"><a href="#DDL语句" class="headerlink" title="DDL语句"></a>DDL语句</h2><h3 id="库和表的管理"><a href="#库和表的管理" class="headerlink" title="库和表的管理"></a>库和表的管理</h3><p>库的管理：</p><pre><code>一、创建库create database 库名二、删除库drop database 库名</code></pre><p>表的管理：<br>    #1.创建表</p><pre><code>CREATE TABLE IF NOT EXISTS stuinfo(    stuId INT,    stuName VARCHAR(20),    gender CHAR,    bornDate DATETIME    );DESC studentinfo;#2.修改表 alter语法：ALTER TABLE 表名 ADD|MODIFY|DROP|CHANGE COLUMN 字段名 【字段类型】;#①修改字段名ALTER TABLE studentinfo CHANGE  COLUMN sex gender CHAR;#②修改表名ALTER TABLE stuinfo RENAME [TO]  studentinfo;#③修改字段类型和列级约束ALTER TABLE studentinfo MODIFY COLUMN borndate DATE ;#④添加字段ALTER TABLE studentinfo ADD COLUMN email VARCHAR(20) first;#⑤删除字段ALTER TABLE studentinfo DROP COLUMN email;#3.删除表DROP TABLE [IF EXISTS] studentinfo;</code></pre><h3 id="常见类型"><a href="#常见类型" class="headerlink" title="常见类型"></a>常见类型</h3><pre><code>整型：    小数：    浮点型    定点型字符型：日期型：Blob类型：</code></pre><h3 id="常见约束"><a href="#常见约束" class="headerlink" title="常见约束"></a>常见约束</h3><pre><code>NOT NULLDEFAULTUNIQUECHECKPRIMARY KEYFOREIGN KEY</code></pre><h2 id="数据库事务"><a href="#数据库事务" class="headerlink" title="数据库事务"></a>数据库事务</h2><h3 id="含义"><a href="#含义" class="headerlink" title="含义"></a>含义</h3><pre><code>通过一组逻辑操作单元（一组DML——sql语句），将数据从一种状态切换到另外一种状态</code></pre><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><pre><code>（ACID）原子性：要么都执行，要么都回滚一致性：保证数据的状态操作前和操作后保持一致隔离性：多个事务同时操作相同数据库的同一个数据时，一个事务的执行不受另外一个事务的干扰持久性：一个事务一旦提交，则数据将持久化到本地，除非其他事务对其进行修改</code></pre><p>相关步骤：</p><pre><code>1、开启事务2、编写事务的一组逻辑操作单元（多条sql语句）3、提交事务或回滚事务</code></pre><h3 id="事务的分类："><a href="#事务的分类：" class="headerlink" title="事务的分类："></a>事务的分类：</h3><p>隐式事务，没有明显的开启和结束事务的标志</p><pre><code>比如insert、update、delete语句本身就是一个事务</code></pre><p>显式事务，具有明显的开启和结束事务的标志</p><pre><code>    1、开启事务    取消自动提交事务的功能        2、编写事务的一组逻辑操作单元（多条sql语句）    insert    update    delete        3、提交事务或回滚事务</code></pre><h3 id="使用到的关键字"><a href="#使用到的关键字" class="headerlink" title="使用到的关键字"></a>使用到的关键字</h3><pre><code>set autocommit=0;start transaction;commit;rollback;savepoint  断点commit to 断点rollback to 断点</code></pre><h3 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别:"></a>事务的隔离级别:</h3><p>事务并发问题如何发生？</p><pre><code>当多个事务同时操作同一个数据库的相同数据时</code></pre><p>事务的并发问题有哪些？</p><pre><code>脏读：一个事务读取到了另外一个事务未提交的数据不可重复读：同一个事务中，多次读取到的数据不一致幻读：一个事务读取数据时，另外一个事务进行更新，导致第一个事务读取到了没有更新的数据</code></pre><p>如何避免事务的并发问题？</p><pre><code>通过设置事务的隔离级别1、READ UNCOMMITTED2、READ COMMITTED 可以避免脏读3、REPEATABLE READ 可以避免脏读、不可重复读和一部分幻读4、SERIALIZABLE可以避免脏读、不可重复读和幻读</code></pre><p>设置隔离级别：</p><pre><code>set session|global  transaction isolation level 隔离级别名;</code></pre><p>查看隔离级别：</p><pre><code>select @@tx_isolation;</code></pre><h2 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h2><p>含义：理解成一张虚拟的表</p><p>视图和表的区别：</p><pre><code>    使用方式    占用物理空间视图    完全相同    不占用，仅仅保存的是sql逻辑表    完全相同    占用</code></pre><p>视图的好处：</p><pre><code>1、sql语句提高重用性，效率高2、和表实现了分离，提高了安全性</code></pre><h3 id="视图的创建"><a href="#视图的创建" class="headerlink" title="视图的创建"></a>视图的创建</h3><pre><code>语法：CREATE VIEW  视图名AS查询语句;</code></pre><h3 id="视图的增删改查"><a href="#视图的增删改查" class="headerlink" title="视图的增删改查"></a>视图的增删改查</h3><pre><code>1、查看视图的数据 ★SELECT * FROM my_v4;SELECT * FROM my_v1 WHERE last_name=&#39;Partners&#39;;2、插入视图的数据INSERT INTO my_v4(last_name,department_id) VALUES(&#39;虚竹&#39;,90);3、修改视图的数据UPDATE my_v4 SET last_name =&#39;梦姑&#39; WHERE last_name=&#39;虚竹&#39;;4、删除视图的数据DELETE FROM my_v4;</code></pre><h3 id="某些视图不能更新"><a href="#某些视图不能更新" class="headerlink" title="某些视图不能更新"></a>某些视图不能更新</h3><pre><code>包含以下关键字的sql语句：分组函数、distinct、group  by、having、union或者union all常量视图Select中包含子查询joinfrom一个不能更新的视图where子句的子查询引用了from子句中的表</code></pre><h3 id="视图逻辑的更新"><a href="#视图逻辑的更新" class="headerlink" title="视图逻辑的更新"></a>视图逻辑的更新</h3><pre><code>#方式一：CREATE OR REPLACE VIEW test_v7ASSELECT last_name FROM employeesWHERE employee_id&gt;100;#方式二:ALTER VIEW test_v7ASSELECT employee_id FROM employees;SELECT * FROM test_v7;</code></pre><h3 id="视图的删除"><a href="#视图的删除" class="headerlink" title="视图的删除"></a>视图的删除</h3><pre><code>DROP VIEW test_v1,test_v2,test_v3;</code></pre><h3 id="视图结构的查看"><a href="#视图结构的查看" class="headerlink" title="视图结构的查看"></a>视图结构的查看</h3><pre><code>DESC test_v7;SHOW CREATE VIEW test_v7;</code></pre><h2 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h2><p>含义：一组经过预先编译的sql语句的集合<br>好处：</p><pre><code>1、提高了sql语句的重用性，减少了开发程序员的压力2、提高了效率3、减少了传输次数</code></pre><p>分类：</p><pre><code>1、无返回无参2、仅仅带in类型，无返回有参3、仅仅带out类型，有返回无参4、既带in又带out，有返回有参5、带inout，有返回有参注意：in、out、inout都可以在一个存储过程中带多个</code></pre><h3 id="创建存储过程"><a href="#创建存储过程" class="headerlink" title="创建存储过程"></a>创建存储过程</h3><p>语法：</p><pre><code>create procedure 存储过程名(in|out|inout 参数名  参数类型,...)begin    存储过程体end</code></pre><p>类似于方法：</p><pre><code>修饰符 返回类型 方法名(参数类型 参数名,...)&#123;    方法体;&#125;</code></pre><p>注意</p><pre><code>1、需要设置新的结束标记delimiter 新的结束标记示例：delimiter $CREATE PROCEDURE 存储过程名(IN|OUT|INOUT 参数名  参数类型,...)BEGIN    sql语句1;    sql语句2;END $2、存储过程体中可以有多条sql语句，如果仅仅一条sql语句，则可以省略begin end3、参数前面的符号的意思in:该参数只能作为输入 （该参数不能做返回值）out：该参数只能作为输出（该参数只能做返回值）inout：既能做输入又能做输出</code></pre><h1 id="调用存储过程"><a href="#调用存储过程" class="headerlink" title="调用存储过程"></a>调用存储过程</h1><pre><code>call 存储过程名(实参列表)</code></pre><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="创建函数"><a href="#创建函数" class="headerlink" title="创建函数"></a>创建函数</h3><p>学过的函数：LENGTH、SUBSTR、CONCAT等<br>语法：</p><pre><code>CREATE FUNCTION 函数名(参数名 参数类型,...) RETURNS 返回类型BEGIN    函数体END</code></pre><h3 id="调用函数"><a href="#调用函数" class="headerlink" title="调用函数"></a>调用函数</h3><pre><code>SELECT 函数名（实参列表）</code></pre><h3 id="函数和存储过程的区别"><a href="#函数和存储过程的区别" class="headerlink" title="函数和存储过程的区别"></a>函数和存储过程的区别</h3><pre><code>        关键字        调用语法    返回值            应用场景函数        FUNCTION    SELECT 函数()    只能是一个        一般用于查询结果为一个值并返回时，当有返回值而且仅仅一个存储过程    PROCEDURE    CALL 存储过程()    可以有0个或多个        一般用于更新</code></pre><h2 id="流程控制结构"><a href="#流程控制结构" class="headerlink" title="流程控制结构"></a>流程控制结构</h2><h3 id="系统变量"><a href="#系统变量" class="headerlink" title="系统变量"></a>系统变量</h3><p>一、全局变量</p><p>作用域：针对于所有会话（连接）有效，但不能跨重启</p><pre><code>查看所有全局变量SHOW GLOBAL VARIABLES;查看满足条件的部分系统变量SHOW GLOBAL VARIABLES LIKE &#39;%char%&#39;;查看指定的系统变量的值SELECT @@global.autocommit;为某个系统变量赋值SET @@global.autocommit=0;SET GLOBAL autocommit=0;</code></pre><p>二、会话变量</p><p>作用域：针对于当前会话（连接）有效</p><pre><code>查看所有会话变量SHOW SESSION VARIABLES;查看满足条件的部分会话变量SHOW SESSION VARIABLES LIKE &#39;%char%&#39;;查看指定的会话变量的值SELECT @@autocommit;SELECT @@session.tx_isolation;为某个会话变量赋值SET @@session.tx_isolation=&#39;read-uncommitted&#39;;SET SESSION tx_isolation=&#39;read-committed&#39;;</code></pre><h3 id="自定义变量"><a href="#自定义变量" class="headerlink" title="自定义变量"></a>自定义变量</h3><p>一、用户变量</p><p>声明并初始化：</p><pre><code>SET @变量名=值;SET @变量名:=值;SELECT @变量名:=值;</code></pre><p>赋值：</p><pre><code>方式一：一般用于赋简单的值SET 变量名=值;SET 变量名:=值;SELECT 变量名:=值;方式二：一般用于赋表 中的字段值SELECT 字段名或表达式 INTO 变量FROM 表;</code></pre><p>使用：</p><pre><code>select @变量名;</code></pre><p>二、局部变量</p><p>声明：</p><pre><code>declare 变量名 类型 【default 值】;</code></pre><p>赋值：</p><pre><code>方式一：一般用于赋简单的值SET 变量名=值;SET 变量名:=值;SELECT 变量名:=值;方式二：一般用于赋表 中的字段值SELECT 字段名或表达式 INTO 变量FROM 表;</code></pre><p>使用：</p><pre><code>select 变量名</code></pre><p>二者的区别：</p><pre><code>        作用域            定义位置        语法</code></pre><p>用户变量    当前会话        会话的任何地方        加@符号，不用指定类型<br>局部变量    定义它的BEGIN END中     BEGIN END的第一句话    一般不用加@,需要指定类型</p><h3 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h3><p>一、if函数<br>    语法：if(条件，值1，值2)<br>    特点：可以用在任何位置</p><p>二、case语句</p><p>语法：</p><pre><code>情况一：类似于switchcase 表达式when 值1 then 结果1或语句1(如果是语句，需要加分号) when 值2 then 结果2或语句2(如果是语句，需要加分号)...else 结果n或语句n(如果是语句，需要加分号)end 【case】（如果是放在begin end中需要加上case，如果放在select后面不需要）情况二：类似于多重ifcase when 条件1 then 结果1或语句1(如果是语句，需要加分号) when 条件2 then 结果2或语句2(如果是语句，需要加分号)...else 结果n或语句n(如果是语句，需要加分号)end 【case】（如果是放在begin end中需要加上case，如果放在select后面不需要）</code></pre><p>特点：<br>    可以用在任何位置</p><p>三、if elseif语句</p><p>语法：</p><pre><code>if 情况1 then 语句1;elseif 情况2 then 语句2;...else 语句n;end if;</code></pre><p>特点：<br>    只能用在begin end中！！！！！！！！！！！！！！！</p><p>三者比较：<br>            应用场合<br>    if函数        简单双分支<br>    case结构    等值判断 的多分支<br>    if结构        区间判断 的多分支</p><h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><p>语法：</p><pre><code>【标签：】WHILE 循环条件  DO    循环体END WHILE 【标签】;</code></pre><p>特点：</p><pre><code>只能放在BEGIN END里面如果要搭配leave跳转语句，需要使用标签，否则可以不用标签leave类似于java中的break语句，跳出所在循环！！！</code></pre>]]></content>
      
      
      <categories>
          
          <category> SQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQL </tag>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2021/11/16/hello-world/"/>
      <url>/2021/11/16/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
